说到“热修复” ，大家肯定不陌生。稍微对 Flutter 框架有所耳闻，都或多或少听过这个词，说它能极大地提高开发者的开发效率。但深究起来，这句话就多多少少显得有些片面了。

如果大家有做过 JavaScript 或其它前端开发，或许会觉得热修复技术早已成熟了。但对于客户端来说，热修复简直就是“福音”。

因为传统意义上，对客户端代码的修改只能通过重新运行的方式才能有所体现。而对于耗时较长的编译，意味着每次代码修改都要等待很长时间才能运行在设备上，又因为很多使用 Flutter 开发的程序员其实之前都是做客户端（Android/iOS）的，所以对大部分人来说热修复太友好了，受到大部分人的追捧，热修复特性才显得那么“知名”。

但其实，“热修复”是一个概括性的词汇。其中包含“**热重载**”和“**热重启**”，而且它们其实还有一些限制，使用的方式也有所区别。与它们相对的则是完全重新运行。所以在开始之前，我觉得有必要先澄清一下概念。重点是明确热重载与热重启，以及它们的区别。

先要明确的是，**热重载并非 Flutter 引入的特性，而是 Dart 编程语言就支持的功能**。而且 Flutter 框架在 **Web 端不支持热重载，只支持热重启**。

## 实战热重载

我们先说热重载，新建一个项目，然后运行起来。就会看到一个简单的计数器 App，相信大家已经喜闻乐见了。

下面，打开 Run 视图，然后聚焦上方的 Console 区，如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35a9c37618b425b99f1d49693830e75~tplv-k3u1fbpfcp-zoom-1.image)

单击 1，出现 Run 视图。在 Run 视图中找到 2 和 3。其中，**2 表示热重载**，**3表示热重启**。

接着，找到 App 界面中央文字区域，改动原有文字，然后点击热重载。具体过程如下：

原代码：

```dart
const Text(
  'You have pushed the button this many times:',
),
```

改动后的代码：

```dart
const Text(
  'You have clicked the button this many times:',
),
```

然后按 Ctrl + S 保存代码，或手动点击 2 号那个像闪电似的按钮，界面将发生如下变化：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77893b530c3647bca8171f230cd7ee97~tplv-k3u1fbpfcp-zoom-1.image)

仔细观察上图红色框住的部分，是不是发生了变化？这就是热重载较为简单的示例了。体现了**热重载的第一个特点：快速显示变化**。

此外，热重载是支持保存状态的，状态可以简单理解成数据。比如，先点击几次右下角蓝色的按钮，然后再执行一次热重载，屏幕中间的数字并不会归零。这就是**热重载的另一特点：能保存状态**。这一点已经说的比较清楚，我就不再放图了，大家自行尝试体会。

接下来我们继续尝试。

屏幕中间的数字在代码中对应的变量是 _counter，当我们试图改变其初始值（初始值为 0，请将其改为不为 0 的任何整数）并执行热重载时，会发现界面并没有变化。这到底是怎么回事呢？

这是因为，当用户界面不发生改变时，通常热重载会失效。**Flutter 框架在执行热重载时，会重建整个组件树，并保持状态，但不会重新运行 main() 或 initState()。** 换言之，如果 build() 方法中的代码没有发生改变，热重载会执行，但不会看到任何效果。

当然这只是热重载的限制之一，我会在后文列举更多的限制条件。

所以某些开发者在调试 Flutter App 时，总会奇怪为什么热重载不生效，其实是其执行策略决定的。暴露的则是开发者自身概念不清的问题，大家可不要再栽跟头了。

那么，有没有办法使其生效呢？当然有，让我们有请热重启登场！

## 实战热重启

还记得热重启按钮的位置吗？它在热重载右边。改变 _counter 初始值后，保存代码并执行热重启，稍后便会在 App 界面上看到最新的修改了。

这里请大家用心观察和比较热重载和热重启执行时的区别，你会发现热重启往往需要花更多的时间。这是因为它真的会**重启整个 Flutter App，并且不会保留状态。** 大家可以尝试点击右下角的按钮让数字发生变化，然后再执行热重启，会发现数字将变为初始值。

现在，让我们总结一下热重载和热重启的共性和区别：

-   **共同点：都能将变化后的代码快速地部署到目标设备上，与完全重新编译相比，极大地提高了效率；**
-   **不同点：热重载能保持状态，热重启则会重启整个 App，更加“彻底”，但无法保留状态。**

## 盘点热重载无能为力的几种情况

从前面的例子中我们已经有所体会，虽然热重载很好用，但会有一些限制。一旦遇到了这些限制，热重载就无能为力了，即使执行成功，也无法看到效果。此时，就需要执行热重启，或者重新编译整个代码了。

下面我们就来盘点一下那些热重载不适用的情况。

### App 被“Kill 掉”

所谓被“Kill 掉”，就是指程序出于某种原因强行停止了。比如 Android 设备为了更优地使用系统资源，会自动停止处于后台的程序；程序在运行时崩溃了，也会被强行停止。

### 代码发生编译时错误

如果修改的代码本身就有问题，连编译都无法进行，热重载便无从谈起。比如我们在一行代码的末尾去掉个分号，然后执行热重载，便会在控制台看到如下报错：

> Performing hot reload...
>
> Syncing files to device Android SDK built for x86...
>
> lib/main.dart:113:5: Error: Expected ';' after this.
>
> )
>
> ^

此时，如果我们修复了代码错误，热重载就又能用了。

### 平台原生代码发生修改

对于 Flutter 层面的代码，热重载是可用的。但如果涉及到平台原生代码的修改，就只能按照传统的完全重新编译运行来使更改生效了。这种情况在使用平台通道进行原生功能开发时会经常发生。

### 更改组件字体

当我们更改组件中使用的资源文件时，热重载几乎都能及时地反映到界面上。但如果更改默认字体，热重载则不会生效，这一点是比较容易忽略的。此时，需要执行热重启即可。

### 添加新的库

在 pubspec.yaml 文件中添加库后热重载无法生效，甚至热重启也不行。因为某些库可能包含平台原生代码，所以需要完整的重新编译运行。

### 某些复杂的手势组件发生变化

在某些需要复杂的手势场景中，热重载会失效。比如在某些本身就具有手势识别的组件（比如 ListView）外继续添加 GestureDetector 组件时，onTap() 中的代码有可能不会执行，需要重新编译运行才可以。

## 小结

🎉 恭喜，您完成了本次课程的学习！

📌 以下是本次课程的重点内容总结：

本讲为大家介绍了 Flutter 框架中的热修复特性。

正如我们所知，热修复特性极大地提高了开发阶段的编码效率。该特性包含“**热重载**”和“**热重启**”。

**执行热重载时，会重建整个组件树，并保持状态。但不会重新运行 main() 或 initState()。执行热重启时，会真的重启整个 App。**

**它们的共同点是都能将变化后的代码快速地部署到目标设备上，与完全重新编译相比，极大地提高了效率；它们的不同点是热重载能保持状态，热重启则会重启整个 App，更加“彻底”，也就无法保留状态了。**

此外，针对一些特殊场景，热重载是无法发挥功效的。只能执行热重启或完整的重新编译运行。对于这些特殊的场景，其实大家也没必要死记硬背，而且我在这里也并未覆盖所有的情况。在实际开发中，如果我们坚信代码是正确的，但热重载后的结果就是不对，那就换做执行热重启试试，实在不行就干脆重新编译。相信我，热重载在大多数时候都是可以信赖的。

➡️ 在下次课程中，我们依然继续探索 Flutter 基础部分。我将为大家带来 Flutter 框架与原生平台代码交互的方法，这种方法被称为“平台通道”。之所以需要“平台通道”，是因为某些平台专有的功能，实现起来还得靠原生代码才行，所以在实现这类需求的时候就显得特别重要了。