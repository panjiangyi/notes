# 简单 diff 算法

双循环遍历新旧虚拟 dom。

外层循环是新虚拟 dom: 记作 new，

内层循环是旧虚拟 dom:记作 old

## 步骤

1. let lastIndex = 0;

2. 拿到 new[i].key，在内层循环中找 old 中相同 key 的索引:index
   1. 如果 index>= lastIndex. 代表 new[i]不需要移动
   2. 如果 index< lastIndex. 代表 new[i]需要移动。
      1. 移动到 new[i-1]后面。
   3. 如果 index 不存在的。代表 new[i]是新增的节点.
      1. 挂载到 new[i-1]后面
3. 此时双循环遍历完毕。
4. 遍历 old，去 new 中找对应的 key 是否存在
   1. 如果不存在，代表 old[i]需要被卸载。

# 双端 diff

从新旧两条链的两端同时开始比较。

> 每循环完一次，都假设被匹配上处理过之后的节点不存在
>
> 于是，这是一个数学归纳法式的问题，一个大问题分解成一步一步，最后只是对比新旧各两个节点的问题

每次循环匹配上某两个。

对指向头部的 index 则+1

对指向尾部的 index 则-1

结束条件：两条链都头 index > 尾 index 了

## 新头和旧头

无需移动

如果匹配上，更新 dom 节点。

## 新尾和旧尾

无需移动

如果匹配上，更新 dom 节点

## 新尾和旧头

如果匹配上，需要移动

把旧头移动到旧尾的后面

## 新头和旧尾

如果匹配上，需要移动

把旧尾移动到旧头的前面

## 如果以上4个条件都没满足

拿新头去旧链中去找key相同的节点

- 如果找到
  1. 把旧链中找到的节点对应的dom移动到，旧头之前
  2. 把旧链中这个索引处置为undefined
  3. 以后循环的时候，如果旧头是undefined，则直接进行下一次循环
- 如果没找到
  - 代表这是一个新节点。直接挂载到旧头之前

## 如果循环结束后还有节点遗漏

- 新链中还有节点未被处理。则挂载这些节点
- 旧链中还有节点未被处理，则卸载这些节点
