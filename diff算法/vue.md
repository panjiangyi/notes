# 简单 diff 算法

双循环遍历新旧虚拟 dom。

外层循环是新虚拟 dom: 记作 new，

内层循环是旧虚拟 dom:记作 old

## 步骤

1. let lastIndex = 0;

2. 拿到 new[i].key，在内层循环中找 old 中相同 key 的索引:index
   1. 如果 index>= lastIndex. 代表 new[i]不需要移动
   2. 如果 index< lastIndex. 代表 new[i]需要移动。
      1. 移动到 new[i-1]后面。
   3. 如果 index 不存在的。代表 new[i]是新增的节点.
      1. 挂载到 new[i-1]后面
3. 此时双循环遍历完毕。
4. 遍历 old，去 new 中找对应的 key 是否存在
   1. 如果不存在，代表 old[i]需要被卸载。

# 双端 diff

从新旧两条链的两端同时开始比较。

> 每循环完一次，都假设被匹配上处理过之后的节点不存在
>
> 于是，这是一个数学归纳法式的问题，一个大问题分解成一步一步，最后只是对比新旧各两个节点的问题

每次循环匹配上某两个。

对指向头部的 index 则+1

对指向尾部的 index 则-1

结束条件：两条链都头 index > 尾 index 了

## 新头和旧头

无需移动

如果匹配上，更新 dom 节点。

## 新尾和旧尾

无需移动

如果匹配上，更新 dom 节点

## 新尾和旧头

如果匹配上，需要移动

把旧头移动到旧尾的后面

## 新头和旧尾

如果匹配上，需要移动

把旧尾移动到旧头的前面

## 如果以上4个条件都没满足

拿新头去旧链中去找key相同的节点

- 如果找到
  1. 把旧链中找到的节点对应的dom移动到，旧头之前
  2. 把旧链中这个索引处置为undefined
  3. 以后循环的时候，如果旧头是undefined，则直接进行下一次循环
- 如果没找到
  - 代表这是一个新节点。直接挂载到旧头之前

## 如果循环结束后还有节点遗漏

- 新链中还有节点未被处理。则挂载这些节点

- 旧链中还有节点未被处理，则卸载这些节点

  



# 快速diff

## 处理相同的前置和后置元素

先从两端遍历新旧两条链，把两端位置没有变的节点都找出来，更新他们。

然后进入下一步，处理两条链剩余的部分的移动，挂载和卸载

##  移动，挂载和卸载

1. 把新链中的剩余节点在旧链中的索引，保存成一个数组：source。默认值为-1，代表是新节点需要被挂载。

2. 求这个数组的最长递增子序

   > source数组中每一项代表的节点，在新链中的索引的递增的
   >
   > 最长递增子序中每一项代表的节点，在旧链中也是递增的。
   >
   > 那么：，最长递增子序列中每一项代表的节点的顺序，在更新前后没有变化
   >
   > 那么：只需要移动其他节点的位置即可

3. 遍历新链，找到所有不在最长递增子序列中的节点，把这些节点移动到在新链中对应的索引位置处即可

   > 把i节点，移动或创建到i+1节点之前。如果i+1节点不存在，就放到父容器尾部。

